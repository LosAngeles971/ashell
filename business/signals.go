package business
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Signals are events generated by UNIX or Linux based operating systems. The system takes some action based upon the signal generated. For example, if we want to cancel a running program, we press CTRL+C. This sends a signal called SIGINT to a program and the underlying system takes appropriate action based upon the signal generated. Understand that the SIGINT is a name associated with a number that designates a particular signal.

Signals are actually software interrupts that can be generated programmatically. They offer a way to handle asynchronous events. Typically, signals are generated by their names, rather than their numbers, to be safe. Understand that most signals and their specific actions are defined by the operating system. They also perform their functions under the purview of the operating system. Therefore, being able to handle some events does not give a limited user a free run to do anything with the system; there are signals that, even if generated, are ignored by the operating system. It is up to the operating system to decide which signals are allowed to be handled by a program.

For example, the SIGKILL and SIGSTOP signals can neither be caught, blocked, or ignored because these signals are critical in maintaining the “sanity” of the operating system functionality. They provide the kernel and root user a way to stop a process under extreme conditions. The number associated with SIGKILL is 9.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
import (
	"os"
	"syscall"

	log "github.com/sirupsen/logrus"
)

var channel = make(chan os.Signal, 1)
var exitchannel = make(chan int)

/*
SIGHUP the signal is sent when a program loses its controlling terminal
SIGINT the signal is sent when the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C)
SIGQUIT the signal is sent when the user at the controlling terminal presses the quit character, which by default is ^\ (Control-Backslash)
SIGTERM the signal is a generic signal used to cause program termination

SIGHUP: This signal is generated when a controlling process dies or hangs up detected on the controlling terminal.
SIGINT: When a process is interrupted from keyboard by pressing CTRL+C
SIGQUIT: Quit from keyboard
SIGILL: Illegal instruction. A synonym for SIGPWR() - power failure
SIGABRT: Program calls the abort() function - an emergency stop.
SIGBUS: Bad memory access. Attempt was made to access memory inappropriately
SIGFPE: FPE = Floating point exception
SIGKILL: The kill signal. The process was explicitly killed.
SIGUSR1: This signal is open for programmers to write a custom behavior.
SIGSEGV: Invalid memory reference. In C when we try to access memory beyond array limit, this signal is generated.
SIGUSR2: This signal is open for programmers to write a custom behavior.
SIGPIPE: This signals us open for programmers to write a custom behavior.
SIGALRM: Process requested a wake up call by the operating system such as by calling the alarm() function.
SIGTERM: A process is killed
*/
func signalsHandler(signal os.Signal) {
	switch signal {
	case syscall.SIGHUP:
		os.Exit(1)
	case syscall.SIGINT:
		log.Infof("session interrupted by signal ( %s )", signal.String())
		os.Exit(1)
	case syscall.SIGTERM:
		os.Exit(1)
	case syscall.SIGQUIT:
		log.Infof("session quit by signal ( %s )", signal.String())
		os.Exit(1)
	default:
	}
}

func signalsListener() {
	for {
		s := <-channel
		signalsHandler(s)
	}
}